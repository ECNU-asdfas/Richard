小百合BBS -- CompSci精华区文章阅读

 发信人: phoenixinter (ACM is AC More!), 信区: Algorithm
标  题: 网络流概念及相关算法介绍
发信站: 南京大学小百合站 (Fri Sep  3 10:41:47 2004)

一、引言


如同我们可以把一个实际的道路地图抽象成一个有向图来计算两点之间的最短路径，我们
也可以将一个有向图看作一个流网络来解决另一类型的问题。流网络比较适合用来模拟液
体流经管道、电流在电路网络中的运动、信息网络中信息的传递等等类似的过程。


二、网络流和最大流问题


给定一个有向图G=(V,E)，把图中的边看作管道，每条边上有一个权值，表示该管道的流量
上限。给定源点s和汇点t，现在假设在s处有一个水源，t处有一个蓄水池，问从s到t的最
大水流量是多少，类似于这类的问题都可归结为网络流问题。


在流网络中，每条有向边可以被看导管。每根导管有一个固定的容量，代表物质流经这个
导管的最大速率，例如一个管道每小时最多能流过200加仑液体或者一根电线最多能承载2
0安培的电流。流网络中的顶点可以看作是导管的连接处。除了源点和汇点之外，物质流进
每个点的速率必须等于流出这个点的速率。如果我们把研究的物质特化为电流，这种“流
的保持”属性就好像电路中的基尔霍夫电流定律一样。


下面我们用数学语言来进行相关概念的定义：


设G=(V,E)是一个流网络，设c(u, v)>＝0 表示从u到v的管道的流量上限。设s为源，t为汇
。G的流是一个函数f: V×V →R，且满足下面三个特征：

1. 容量限制：对于所有的 u,v ∈ V, 要求f(u, v) <= c(u, v) 

2. 斜对称性：对于所有的 u,v ∈ V, 要求f(u, v) = - f(v, u)

3. 流的保持：对于所有的 u ∈ V - {s, t}，要求：∑ f(u, v) = 0(v∈V)

f(u,v)称为从结点u到v的网络流，它可以为正也可以为负。流 f 的值定义为：|f| = ∑ 
f(s, v)(v∈V)即从源出发的所有流的总和。


最大流问题就是找出给定流网络的最大流。网络流问题可以归结为一类特殊的线性规划问
题。


三、解决最大流问题常用算法一览


解决最大流问题的常用到Ford-Fulkerson方法，之所以称其方法而不是算法，是因为在这
种思想下包含着若干种时间复杂度不同的实现，其中较多地是使用Edmonds-Karp算法。与
此相对，Push-relabel算法采用了与Ford-Fulkerson方法完全不同的思考角度，降低了渐
进意义下的时间复杂度。而relabel-to-front算法则是对Push-relabel算法的改良和精炼
，效率更佳。


关于这三种常用算法的时间复杂度

算法名称                       时间复杂度

Edmonds-Karp算法               O(V*E^2)

一般性的push-relabel算法         O(V^2*E)

relabel-to-front算法               O(V^3)


可以看出，当给定的有向图比较稀疏时，三种算法的效率不会相差太多，但当网络稠密时
，relabel-to-front算法在效率上有着明显的优势。


四、基于Ford-Fulkerson方法的Edmonds-Karp实现


一般的Ford-Fulkerson方法具有迭代性质，我们把顶点u和v之间的流记作f(u,v)。那么在
最开始，我们对所有的u,v∈V置f(u,v)=0。在每次的迭代过程中，通过找到一条增加路径
来使|f|增加。在这里，我们可以简单地认为所谓的“增加路径”就是一条可以传送比当前
更多流的从源点s到汇点t的路径，一旦找到了这样的路径，我们就可以得到一个比原流数
值更大的新流。重复这个过程，直到不存在增加路径为止，这就是Ford-Fulkerson方法的
主要过程，可以用伪码表示如下：


FORD-FULKERSON-METHOD(G,s,t)


将流f初始化为0


while 存在一条增加路径p


do 顺沿p增加f


return f


实现Ford-Fulkerson的时间复杂度主要取决于如何寻找增加路径p。Edmonds-Karp实现正是
通过采用了广度优先的搜索策略得以使其复杂度达到O(V*E^2)。


由于这种算法的效率不很理想，我们在此不多着墨，而主要介绍下述push-relabel算法的
思想。


五、一般性的push-relabel算法


很多渐进意义下最优的算法都是采用了push-relabel算法的思想，而且很多其他的相关问
题，比如最小费用流问题，也可以用这种方法很好的解决。首先介绍的是一般性的push-r
elabel算法。


不同于Ford-Fulkerson方法在残留网络中寻找增加路径的方式，push-relabel算法在运行
的过程中只关注某一个顶点以及它的相邻顶点，在这个过程中，它并不像Ford-Fulkerson
方法保持着“流的保持”性质，而是以一个“先流”进行运作。这个先流同样是一个 V×
V →R的函数，满足容量限制和斜对称性，同时，它对所有的u∈V-{s}满足f(V,u)>=0。我
们记e(u)=f(V,u)。如果e(u)>0我们就说顶点u溢出。


为了步入正题，我们还需要介绍push-relabel算法引入的一个额外的高度函数。设G=(V,E
)是一个流网络，源点是s，汇点是t，f是G中的一个先流。如果函数h:V→N满足h(s)=|V|，
h(t)=0，而且对残留网络中所有的边(u,v)有h(u)<=h(v)+1，那么称h是一个高度函数。



正如其名称一样，push-relabel算法有两个基本操作:push和relabel。一般性的push-rel
abel算法就是通过往复执行这两种操作完成的：


GENERIC-PUSH-RELABEL(G)


先流初始化


while 存在可以执行的push或relabel操作


　　选择一个可以执行的push或relabel操作执行


下面具体介绍一下这两个基本操作。

PUSH(u,v) 可以执行的时机：顶点u溢出，u、v之间的残留容量cf(u,v)为正，且h[u]=h[v
]+1

动作描述：将df(u,v)=min(e[u],cf(u,v))个单位的流从u压向v


具体步骤：


df(u,v)=min(e[u],cf(u,v))


f[u,v]=f[u,v]+df(u,v)


f[v,u]=-f[u,v]


e[u]=e[u]-df[u,v]


e[v]=e[v]+df[u,v]


RELABEL(u)

可以执行的时机：u溢出，且对所有的残留网络中的边(u,v),有h[u]<=h[v]


动作描述：增加u的高度


具体步骤：


h[u]=1+min{h[v]:(u,v)是残留网络中的边}


通过证明，在一般性的push-relabel算法执行过程中，relabel操作的执行次数小于2|V|^
2，push操作的执行次数小于2|V||E|+4|V|^3+4|E||V|^2，而每个relabel操作的耗时在O(
V)级，每个push的耗时在O(1)级，选择一个可以执行的操作也可以在O(1)内完成，因此，
存在具体的实现使得一般性的push-relabel算法时间复杂度达到O(V^2*E)。


六、relabel-to-front算法


通过引入邻接表和许可边的概念，relabel-to-front算法在push-relabel算法的基础上进
一步提升了效率，使时间复杂度可以达到O(V^3)，但是该算法的步骤和证明的过程比较繁
琐，在这里就略去了，有兴趣的读者可以参考《算法导论》。


七、二部图的最大匹配与网络最大流的关系


有一定离散基础的读者应当对二部图的最大匹配不陌生，但它和网络流之间有什么具体的
联系呢？


是的，如果我们设二部图两部分的点集分别为L与R,现在添加源点s和汇点t,对所有的v∈L
添加有向边(s,v)，再对所有的v∈R添加有向边(v,t)，再将原二部图中所有的无向边改为
自L中的点指向R中的点的有向边，就构造了一个流网络。如果这个网络中每条边的容量限
制都设为1，那么它的最大流数值就等于二部图的匹配数，而且这个最大流和二部图中的最
大匹配是一一对应的。


用邻接表存储的二部图可以用匈牙利算法在O(VE) 的时间内找到最大匹配，这意味着用网
络流解决二部图最大匹配问题并非最具效率的选择，但是它至少向我们展示了网络流的一
个侧面应用。除此之外，网络流的变形和演化还可以解决很多具有普遍意义的问题，比如
最小路径覆盖等等，所以笔者建议对图论感兴趣的同学不妨多研究一下相关内容，一定会
有所收获。
--
传说中有一种鸟

在大限到来之时

集梧桐枝干自燃

在烈火中新生...

这种鸟就是凤凰

这种奇迹就是凤の涅磐。


※ 来源:．南京大学小百合站 http://bbs.nju.edu.cn[FROM: 210.29.249.168]



[返回上一页] [返回上级目录][本讨论区]