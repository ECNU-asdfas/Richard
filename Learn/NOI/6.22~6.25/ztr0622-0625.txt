题目来源：CodeChef CHEFAFD
题目大意：n*n的棋盘，每个位置有一个方向的可选集合（上下左右）。
给每个位置保留唯一的方向，使得从任意一个位置开始，不断按当前位置的方向走，不会走出棋盘且能走回原位置。
T<=50，n<=150，3s。
题目解法：相当于每个位置保留一个出边（出度为1），图中形成了若干个环，即要求了每个位置入度也为1。
每个位置拆两个点，将一个可行方向的入度和出度配上，跑二分图匹配即可。





题目来源：CodeChef KIRMEME
题目大意：给定一棵带点权的树，求有多少条链，将点权依次取下来构成序列，峰的数量在L到R之间。
峰就是指，一个位置的值比相邻两个位置的值都要大。
T<=20，n<=5e4，1.5s。
题目解法：基础点分治练习题，接口处考虑一下，枚举一边多少个峰，另一边按限制拿出区间和就好了。





题目来源：CodeChef GEOCHEAT
题目大意：每次加入一个点，询问当前最远点对距离。保证所有点的加入顺序是随机打乱的（坐标不随机）。
n<=7.5e5，2.5s。
题目解法：考虑全部点都在的时候的最远点对，是i号点和j号点。由于顺序随机，所以max(i,j)期望是2/3*n。
此时max(i,j)之后的答案显然都是一样的，而之前的答案暴力递归做。考虑等比数列求和，每次最远点对的规模之和是线性的。





题目来源：CodeChef TREEBAL
题目大意：有一棵n个点的有根树，每条边有长度（整数）和权值（正整数）。
你使一条边的长度增加1或减少1的代价是这条边的权值，用最小的总代价使得每个叶子到根的距离（路径上的边的长度之和）相等。
n<=2e5，3s。
题目解法：对每个点维护一个函数f(x)，表示限制该点到子树中所有叶子的距离均为x时，最小的总代价。
这是一个分段函数，用平衡树来维护，向上推时用启发式合并来实现。





题目来源：CodeChef SEAPERM3
题目大意：我们认为一个排列p[1..n]是好的，当且仅当存在i,j使得p[i]>j且p[j]>i。
限制该排列的m个位置的取值，问好的排列数量，模一般质数。
T<=10，n<=1e9，m<=1e4，3s。
题目解法：计算不好的排列的数量。可以发现如果某个位置有p[i]>i+2，那么这个排列一定不好。
考虑p[i]<=i+2的情况，首先只有相邻的位置才可能出现令其好的情况，其次此时前i个位置的取值情况并没有多少种，可以状压。
m=0的时候直接矩阵快速幂，有限制的时候分段做就好了。
最后要用n的阶乘减，考虑用分块打表的方法来计算这个结果。





题目来源：CodeChef BIKE
题目大意：给定一个n个点有向图，每条边有A类和B类权值，再给定一个t。对于每个1<=k<=n，0<=i<n，0<=j<n-1，求出：
从k号点开始，走恰好t条边回到k号点，经过这些边的A类权值和模n为i，B类权值和模(n-1)为j的方案数，模1163962801(2*2*2*2*3*3*5*5*7*11*13*17*19+1)。
n<=22，t<=1e9，7s
题目解法：暴力是怎么做的：有向图这一维用矩阵乘法；考虑A、B类权值和这两维，因为n和(n-1)互质，用中国剩余定理合并一下就是一维n*(n-1)的循环卷积。
于是矩阵乘法的每一个元素存一个多项式，然后快速幂。这样的做法是O(n^5lognlogt)的，算一下大概1e9级别，带上fft常数并不能过。
考虑如何优化，矩阵乘法这一维肯定是丢不掉的。发现这个循环卷积的下标是模n*(n-1)意义下的，而(P-1)是任何一个n*(n-1)的倍数。
也即，一定能找到w，使得模P意义下w^1...w^[n*(n-1)-1]均不为1而w^[n*(n-1)]为1，把这些值带进去算点值，循环卷积就能转化为点值相乘。
这样就去掉了一个logn和大量的常数，可以通过此题。






