题目来源:https://www.hackerrank.com/contests/101hack46/challenges/counting-road-networks

题目大意:求n个点带标号无向联通图个数。

题目解法:

你tm在逗我？

首先把dp式子写出来

模数如果能NTT就多项式求逆,否则分治FFT

--------------------------------------------------------------------------------------------

题目来源:https://www.hackerrank.com/contests/w28/challenges/suffix-rotation

题目大意:你有一个长度为$n$的字符串,每一轮你可以选择一个长度为$x$的后缀（选择的长度要严格小于上一次的后缀）并且把它旋转任意长度，要求最后字符串是sort过的，求最小的操作轮数。

n \leq 1000

题目解法：

把字符串看成环,可以看成你有一个指针,并且可以花1的代价任意移动,花0的代价把指针指的字符删了并且指针移动到下一位，并且你要按顺序删

知道这个之后你就可以dp,f[i][j]表示删了前i个字符现在在j的最小花费，直接按定义转移就是cn^2,优化一下似乎能做到O(n)


--------------------------------------------------------------------------------------------

题目来源:https://www.hackerrank.com/contests/w27/challenges/coprime-paths

题目大意:给你一棵树，树上有点权，每次询问一条路径上有多少个点gcd(v_x,v_y)==1

n,q\leq 25000

v_i 最多三个本质不同的质因数

题目解法:

首先肯定是树上莫队,考虑怎么计算gcd为1的数量，因为每个数最多三个本质不同质因数，所以直接容斥算，加入和删除的时候都是2^3。。。。时间复杂度O(2^3 (Q+N)\sqrtN)

-------------------------------------------------------------------------------------------

题目来源:https://www.hackerrank.com/contests/w27/challenges/how-many-substrings

题目大意:给一个字符串,每次询问区间本质不同子串个数。

n\leq 10^5

题目解法:

把询问离线,不断往后缀树上加字符,每个询问在右端点处处理.

维护ans[x]表示左段点为x时的答案

考虑后缀树上每个串对每个询问的贡献，令R(i)表示这个串最右边的出现位置，那大概就是R(i)-Len(i)>=L(Q)这种形式。修改R(i)大概就是在ans上加一个等差序列和区间加状物。

考虑更新的时候，每次会把它到根的所有串的R(i)都修改为当前值,直接暴力修改复杂度是不对的，但是注意到我们能把R(i)相同的连续一段一起修改。如果我们一起修改，这个复杂度显然就对了，因为这和LCT的access操作是等价的。

如果我们不想写区间加等差数列,可以把ans作差，这样只要区间加区间求和

-----------------------------------------------------------------------------------------

题目来源:https://www.hackerrank.com/contests/hourrank-17/challenges/number-game-on-a-tree

题目大意:两个人玩游戏，对于一个可重集合，两个人轮流取数，每个人取的数不能大于上一个人取的，不能操作的人输。

现在给你一棵树，树边上有权值，问多少条路径上的边组成的可重集先手必胜

题目解法：

首先，这个可重集如果每个数出现次数都是偶数那么先手必败，不然先手必胜

然后就问多少个路径每种权值出现偶数次

每种权值赋一个随机权值，xor和等于0..直接算

O(n)

-----------------------------------------------------------------------------------------

题目来源:https://www.hackerrank.com/contests/w23/challenges/sasha-and-swaps-ii

题目大意:对于i in [1,n] ,问有多少不同的排列能在i次swap操作内变成{1,2...n}

题目解法:

考虑一个排列最小几次能变成{1,2...n}，令x为它的置换个数,那么显然就是n-x次

如果一个排列能x次变{1,2..n},那么它x+1次肯定不行(考虑逆序对个数)，x+2次肯定行

最少k次能变回{1,2..n}的个数就是一个斯特林数，直接分治FFT复杂度是O(nlog^2n)
