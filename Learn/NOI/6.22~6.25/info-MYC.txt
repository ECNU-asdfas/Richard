题目来源：http://codeforces.com/contest/377/problem/D
题目大意：
    给你n个三元组，Li，vi，Ri（Li<=vi<=Ri）你要选出一个集合S使得对于任意i属于S  max(Li)<=vi<=min(Ri)，输出最大集合size和一种方案。
题目解法：
    考虑已知max(Li)和min(Ri)那么可以二维数点输出最多有多少个点是可以属于这个集合中的。
    一个点可以属于该集合及Li<=max(Li)<=vi&&vi<=min(Ri)<=Ri那么可以把一个三元组看成一个[Li,vi][vi,Ri]的矩形，那就是数在这些矩形并中覆盖最多的点。
    该点的横坐标就是L，纵坐标就是R。可以用扫描线+线段树做。




题目来源：http://codeforces.com/contest/377/problem/E
题目大意：
    你要挣s元钱。你有n个工厂，你需要花费si元钱获得第i个并且将你每秒生产的钱数升为pi，问最少要多少时间才能挣够钱。
题目解法：
    考虑将si排序。对于每个点询问最早能买得起该工厂的时间。pi即每个点的斜率。
    因为贪心考虑pi不会下降，所以可以决策单调。可以用单调队列优化DP。




题目来源：http://codeforces.com/contest/543/problem/D
题目大意：
    给你一棵树，一个方案为合法的当且仅当所有节点到根节点的路径上少于等于一个坏节点。问每个点作为根时方案数。
题目解法：
    首先把1号点作为根时DP求得每个点的子树答案。
    然后再dfs一次，因为每次把根节点从父节点转移至字节点时ans只会父节点其他儿子有关，预处理即可。
    
    
    
    
题目来源：http://codeforces.com/contest/543/problem/E
题目大意：
    给你一个序列ai和一个数m，对于一次询问l，r，q。一个点i的权值为啊a[i]~a[i+m-1]中小于等于q的点数，求l～r的权值最小值。
    （卡空间+强在）
题目解法：
    首先考虑可持久化线段树的做法，可以将ai从小到大插入，每次将[i-m+1,i]的区间++，对于询问就找到当前版本求最大值。
    但是可持久化线段树空间太大。
    考虑分块。先对时间分块，对于没根号次操作保留一个版本，对于每个版本中再对序列分块。
        每个块中维护区间1.最大值和2.前缀++的个数3.块内全体++的次数。同时对于每个版本你要维护非整块修改时对块内最大值的修改。空间O（n）
    对于每次询问：
        首先找到询问前距离询问最近的一个版本，先插入根号n个操作。
        对于整块的可以直接求最大值。对于非整块的询问：
            块内每个点的权值只和全体++和非整块的修改有关
            首先全体++对块内的所有点都有影响，然后考虑当前每个块已知有多少个前缀++。
            然后只会在插入该块中的值才会前缀++，只会在插入a[i+m-1]时才会产生后缀++
            然后从块头到块尾便利所有节点。块头的权值只和前缀++和整体++有关，然后便利下一个点，这个点和前一个点的块内修改只和O（1）个元素有关。
            所以暴力修改即可，若当前点在询问区间内就更新ans。
            





题目来源：http://codeforces.com/contest/559/problem/D
题目大意：
    给你一个凸包，定义一个子凸包为只保留原凸包中若干个点且面积大于0的凸包，求该凸包的子凸包内部整点的期望个数。（精度1e-9）
题目解法：
    首先有pick定理：s=a+1/2b-1
    所以可以转化为求面积期望和和轮廓线上的顶点数。
    考虑一条边对最终答案贡献:一条边对ans的贡献首先要乘上它的出现概率，对于一条距离为k的线段出现概率约为2^k左右，所以可以定个值，若两点距离超过该值则不做处理。




题目来源：http://codeforces.com/contest/559/problem/E
题目大意：
    每个灯可以照亮[ai-li,ai]或[ai,ai+li]求最多照亮线段。
题目解法：
    答案肯定是一段亮一段不亮交替出现。即求亮的区间和。然后对于同一段线段照亮该线段的肯定是连续一段灯。
    所以可以设f[i][j][k]为处理到第i盏灯当前得到照亮区间的右端点为第j盏且为k状态（k=0表示[ai-li,ai],k=1表示[ai,ai+li]）。
    然后考虑转移：枚举一段连续的区间把它作为新的连续一段，然后枚举去区间时从小到大枚举同时记录区间向右最大值。
