题目来源：
	http://agc010.contest.atcoder.jp/tasks/agc010_e
题目大意：
	有一个序列 {a_i} 。
	A 和 B 玩游戏， A 先将这个 {a_i} 重排列， B 能不断交换两个相邻且互质的数。
	A 想让字典序最小， B 想让字典序最大。
	n <= 2e3
题目解法：
	如果 A 排列完毕，那么如果 i 在 j 前且 a_i,a_j 不互质，那么 i,j 的相对位置不发生改变，因此可以表示成一个 DAG 形式， B 会选择其最大拓扑序。
	考虑没有重排列的情况下按位确定。
	如果只有一个联通块，那么这个把最小值拿出来作为根一定合法，因为提根后按照 dfs 序放就能保证。
	因此删去最小点和相关的边，剩下多个联通块，那 B 一定会选择最大的那个根。
	拿个堆维护当前的最大的根即可。
	
题目来源：
	http://agc010.contest.atcoder.jp/tasks/agc010_f
题目大意：
	A 和 B 在玩游戏。
	有一棵 n 个点的树，每个点有个权值 a_i 。
	当前有个指针指在点 i ， A,B 轮流操作，将 a_i 减 1 后移动指针到相邻位置。
	操作开始时指针指向节点权值为 0 的人输。
	问从哪些点开始先手必胜。
题目来源：
	考虑一个必输的点：当它的权值小于等于所有相邻的点时，这个点先手必败。
	否则，这个点上的指针只能向相邻权值小于它的点移动，且不可能走回头路。
	那就对点 i 所在子树的必胜必败态进行转移即可。
	
题目来源：
	http://agc009.contest.atcoder.jp/tasks/agc009_d
题目大意：
	给你一棵 n 个点的树，选择合适的分治中心，使得点分树的深度最小。
	n <= 1e5
题目解法：
	将每个点的权值赋为其在点分树中的高度，那么问题变成，给每个点赋值，使得任意两个大小为 k 的节点之间，存在一个权值大于 k 的节点，	最小化权值最大值。
	考虑一个贪心。
	S[i] 表示 i 子树中有哪些权值，它们所在点到根路径上没有的值。
	考虑有两个儿子共同拥有的权值，则 i 的值必须大于它。
	S[son] 的并中的值 i 都不能取。
	在满足条件情况下，取最小的即可。
	
题目来源：
	http://agc009.contest.atcoder.jp/tasks/agc009_e
题目大意：
	黑板上写着 n 个 0 ， m 个 1 ，每次可以选择 k 个合并，问最后可能留下多少种不同的权值。
	保证 k-1 整除 n+m-1
	n , m <= 2e3
题目解法：
	每个数的贡献是 k^{x_i} ，且 \sum k^{x_i} = 1 。
	考虑所有 0 的贡献，令 z = \sum k^{x_i} ， a_i = 0 。
	z 可以写作一个 k 进制小数， 0.z_1z_2z_3...z_n 。
	那么约束条件就是 \sum z_i <= n , k-1 整除 n-\sum z_i 。
	对应的 1 的约束条件就是 \sum k-1-z_i <= m-1 , k-1 整除 m-1-\sum k-1-z_i 。
	直接 DP 即可。	

题目来源：
	http://agc008.contest.atcoder.jp/tasks/agc008_e
题目大意：
	给你一个长度为 n 的序列 {a_i} ，问有多少个 1 到 n 的排列 {p_i} ，对于每个 i ，满足 p_i = a_i 或者 p_{p_i} = a_i 。
	n <= 1e5
题目解法：
	首先，一个排列能表示成多个不相交的环。
	现在考虑全部或部分 p_i 变为 p_{p_i} 后的形态。
		1.不变
		2.奇环，全部都变为 p_{p_i} ，变成了一个新的大小不变的环。
		3.偶环，全部都变为 p_{p_i} ，变成了两个新的大小一半的环。
		4.部分变为 p_{p_i} ，那么会变成一个环加上一些 "辫子" 。
	现在你知道的是变换以后的形态，考虑如何还原回去。
	首先，合法条件是每个联通块都是环或者长辫子的环。
	如果一个联通块已经是长辫子的环，那么考虑它的每条辫子长度和相邻两个长辫子的位置间的距离，可能 ×= 2/1/0 。
	否则，对长度相同的环做一次 DP ，分别考虑 1,2,3 的情况转移。
	
题目来源：
	http://agc008.contest.atcoder.jp/tasks/agc008_f
题目大意：
	给你一棵 n 个点的树。
	定义一个函数 f(x,d) 表示到 x 最短路径经过边数小于等于 d 的点集。
	给出一个点集 S 。
	问所有 x \in S 和任意的 d ,有多少个本质不同的 f(x,d) 。
	n <= 1e5
题目解法：
	其实问题就是解决去重的问题。
	首先要求所有 f(x,d) 都不是全集。
	如果 f(p_s,d1) = f(p_t,d2) ，那么会有 p_s -> p_t 这条路径上的点
		f(p_s,d1) = f(p_{s+1},d1-1) = ... = f(p_m,d_m) = ... = f(p_{t-1},d2-1) = f(p_t,d2) 。
	考虑计算 i 作为 p_m 的 f(i,d) 的数量。
	为方便考虑，将 i 提根。
	合法的 f(i,d) 也就是满足所有与 i 相邻的 j ， f(j,d+1) != f(i,d) 。
	考虑 d 逐渐变大，有些子树满了，就会导致不合法。
	这也就求出了每个 d 的上界。
	当 S 不为全集的时候，大概就是每个 d 有个下界，判一判就好。
