                                                                                                                      题目来源：http://codeforces.com/contest/736/problem/D
题目大意：
    给你n个空位和m个整数对，表示可以在第ai个位置填上bi。你要求出对于删去没个整数对，对于每种删除你要求出合法排列的方案数为奇数。
    对于一种合法方案为所有位置填满且为一个排列。
题目解法：
    首先合法排列为奇数的方案数为行列式为奇数的方案数。
    所以就是要求删除一行一列之后的行列式的值，可以矩阵求逆解决。




题目来源：http://codeforces.com/contest/736/problem/E
题目大意：
    有n个人，两两有一场比赛。赢一场得两分，平一场得一分，输一场不得分，已知前若干名的分数，求构造一种方案使得满足条件。
题目解法：
    首先有一个结论：一个分数合法当且仅当对于前i小的分数和>=i*(i-1)对于所有人的分数和==n*(n-1)。
    然后对于一个方案要让分数越小的分数越大。所以一开始先贪心让未知的所有分数尽可能平均，然后从分数大的开始构造，从分数小的开始比较，能赢就赢，使得分数小的分数不会下降。否则就输，每次重新维护分数从大到小的序列。





题目来源：http://codeforces.com/contest/687/problem/D
题目大意：
    给你一个n个点，m条边的无向图，每条边有边权。每次给你一个区间，表示你将这个区间内的边链接。你要将点分成两个集合，使得连接同一个的边的边权尽可能小。
题目解法：
    考虑一个q×m的做法。从小到大枚举没一条边，对于加入一条边，如果加入这条边使得该图变成非二分图。那么这条边的边权就是ans
    那么可以用线段树先预处理出每段线段中的边构成的非二分图的边。对于一次询问能分成log个区间。至多nlogn条边，再求解。



题目来源：http://codeforces.com/contest/687/problem/E
题目大意：
    
dfs(v)
{
     set count[v] = count[v] + 1
     if(count[v] < 1000)
     {
          foreach u in neighbors[v]
          {
               if(visited[u] is equal to false)
               {
                    dfs(u)
               }
               break
          }
     }
     set visited[v] = true
}

main()
{
     input the digraph()
     TOF()
     foreach 1<=i<=n
     {
          set count[i] = 0 , visited[i] = false
     }
     foreach 1 <= v <= n
     {
          if(visited[v] is equal to false)
          {
               dfs(v)
          }
     }
     ... // And do something cool and magical but we can't tell you what!
}
你要将边重排列，使得count之和最小。

题目解法：
    考虑每个点的所有出边中的第一条边。所以对于一个点它不在环中，那么它可以代价为1。对于对于一个环，如果环上点没有出点，代价为999*（环上点的个数-1），对于有出边的环，代价与非环中的点相同。
    所以只要找出一个强联通分量中的最小环，然后能连到这个强联通分量都可以以1的代价解决。





题目来源：http://codeforces.com/contest/468/problem/D
题目大意：
    给你一棵树，你要给出一个排列ai使得dis(ai,i)的距离和最大。
题目解法：
    dis(i,j)=dep(i)+dep(j)-2*dep(LCA(i,j))考虑以树的重心为根，那么对于没一条路径都可以经过root，所以两两的LCA之和dep都为0.那么对于每条边都至少会经过两边size的较小的次数，这样可以证明是最优的。
    对于求最小字典序，可以贪心，维护当前root最大的一个联通块的大小。如果它的size等于其他的联通块的size，那么只能从中选择。




题目来源：http://codeforces.com/contest/468/problem/E
题目大意：
    给你一个n×n的矩阵，上面有k个数为给定数，其他数为1。求这个矩阵的permanent值。这个值的定义与行列式类似。（将(-1)^(i+j)去除）。
    \operatorname{perm}(A)=\sum_{\sigma\in S_n}\prod_{i=1}^n a_{i,\sigma(i)}.
题目解法：
    先考虑一个矩阵上的点可以看作横坐标连向纵坐标的二分图，那么ans就相当于每个匹配的边权乘积和。
    对于两个没有连通的联通块，ans就等于两个联通块的乘积和。因为两者没有横坐标或纵坐标相同，两者相对独立。
    对于一个联通块，首先点数小于2*k，边数小于k。
    考虑两边的点数min。
    1.如果min<=s,那么可以考虑2^min的状压表示当前的点是否选入，状压Dp。
    2.如果min>s，那么总点数大于2s，那么考虑一棵生成树，树边是大于等于2s的，那么非树边最多只有（k-2s）条。也可以2^(k-2s)枚举每条非树边是否被选入。对于选入的非树边的点可以删除，对于剩下的点树形DP。
    时间复杂度：O(2^(min(k-2s,s))*s^2)=O(2^(s/3)*s^2)
