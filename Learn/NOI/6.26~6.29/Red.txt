题目来源：
	http://agc014.contest.atcoder.jp/tasks/agc014_e
题目大意：
	有一棵 n 个点的数，最初边全为蓝色。
	进行 n-1 次操作，每次选择一条全为蓝色边的路径 u->v ，并删去路径上的某条蓝色边，连上 u->v 的红色边。
	给出最初的蓝色树和最终的红色树，问是否存在一种方案。
	n <= 1e5
题目解法：
	假设我们已知删除顺序 p1,p2...pn-1 和加入顺序 q1,q2...qn-1 。
	我们将整个过程倒过来看，实际上就是选择两个联通块，并在这之间连上两条边后合并。
	模拟这个过程即可。

题目来源：
	http://agc014.contest.atcoder.jp/tasks/agc014_f
题目大意：
	有一个排列 {p_i} 。
	定义一个数 p_j 是大的，当且仅当 p_j>p_j-1,...,p_1 。
	每次操作会把所有大的数放到序列后端，保持相对顺序不变。
	问多少次操作后这个排列有序。
	n <= 1e5
题目解法：
	考虑从前 n-1 大的方案推到前 n 大的方案。
	设前 n-1 大排好序的时间为 T ，考虑 T-1 时序列的情况。
	令第一个数为 f ，若 1 在 2 和 f 之间，那么 n 的情况也为 T ，否则为 T+1 。
	这提示我们关注 1,2,f 的关系。
	实际上我们发现， 1,2,f 的 “圆排列” 顺序不会改变。
	因此我们维护前 i 大排好序的时间和 f ，递推即可。

题目来源：
	http://agc007.contest.atcoder.jp/tasks/agc007_e
题目大意：
	有一棵根为 1 的 n 个点的树，有边权，每个非叶节点都恰有两个儿子。
	要你给出一个访问叶子的顺序，使得访问每条边恰好两次，且访问相邻两个叶子经过的路径长度的最大值最小。
	n <= 1e5
题目解法：
	先二分答案。
	考虑一个树形 DP 。F[i] 表示 i 这个子树，进入花费为 x ，出来花费为 y ，子树内路径合法的状态的集合。
	那么如果 x<x1,y<y1 那么 x1,y1 的状态是完全更劣的，可以舍去。
	因此剩下的状态 x 递增， y 递减。
	考虑合并两个状态，贪心的选择 y 更小的。
	合并后的总状态数是 2*min(|S1|,|S2|) 。
	类似于启发式合并，它的状态数是 O(nlogn) 的。

题目来源：
	http://agc007.contest.atcoder.jp/tasks/agc007_f
题目大意：
	有两个字符串 S0,T。
	每次能对其进行一次操作， S_t[i]=S_t[i-1] 或 S_{t-1}[i] 。
	问最小的 t 使得 St 变为 T 。
	无解输出 -1 。
	Len <= 1e6 。
题目解法：
	从后往前考虑最终 T 中的每个字符的来源是哪个位置。那么这就是一些线段。
	假设我们有线段 (a,b) ，之后一条是(c,d) 。那么一次操作过后可以将其变换为 (c-1,b) 。
	那么我们就对每条线段找到最少的线段条数使得其长度小于等于 0 ，再全部取 max 即为答案。

题目来源：
	http://agc006.contest.atcoder.jp/tasks/agc006_e
题目大意：
	有一个 3*N 的矩阵，第 i 列的元素从上到下依次为 3*i-2,3*i-1,3*i。
	一次操作能旋转一个 3*3 的矩阵。
	给出目标矩阵，问是否能旋转成目标矩阵。
	5 <= n <= 1e6
题目解法：
	考虑一些必要条件：
		1.奇数列始终是奇数列，偶数列同样。
		2.每列的元素不会变。
		3.奇数列逆序对奇偶性与偶数列是否翻转的奇偶性相同，反过来同样。
	这些条件可证明是充分的。
	实际上每列都能归位，只要证明每列都能被翻转回来即可。
	而手算一下是可以用这些操作是翻转任意距离为 2 的列的。
	
题目来源：
	http://agc006.contest.atcoder.jp/tasks/agc006_f
题目大意：
	n 个点的有向图，如果存在 (x,y) (y,z) 那么要补全 (z,x) 。
	问最终图上的边数。
	n <= 1e5 。
题目解法：
	不同联通块分开考虑。
	考虑一条链的情况，最终的情况是模 3 为 1 的点向模 3 为 2 的点连边， 2 向 0 连边， 0 向 2 连边。
	那图也是如此。
	将图 3 染色，如果有解就按上述做，否则必然会出自环，就是无向完全图了。
