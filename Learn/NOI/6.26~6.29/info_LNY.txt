题目来源：http://codeforces.com/contest/512/problem/E
题目大意：
输入n个点的多边形的两个三角剖分，每次可以在两个有公共边的三角形形成的四边形中把那条公共边换成另一条对角线，构造一种方案在20000步内把第一个三角剖分变成第二个。n<=1000
题目解法：
数据范围很小，直接把两个三角剖分分别变成所有对角线与1相连即可。


题目来源：http://codeforces.com/contest/512/problem/D
题目大意：
有一个n个点的无向图，没有重边和自环。一开始没有点被染色。每个点最多被染色一次。一个点如果和超过1个未染色的点有边相连就不能被染色。对于所有0<=k<=n，求依次染色k个点的方案数模1000000009。n<=100
题目解法：
任何环上的节点不可能被染色。先拓扑排序求出所有能被染色的节点。对每个可能被染色的连通块，一定是一棵无根树或者长在环上的树。长在环上的树可以以环上的点为根直接树形DP。对于大小为n的无根树，每个选出k个点的方案可以选n-k个点做根，枚举每个点做树根之后求和再除以n-k就好了。

题目来源：http://codeforces.com/contest/321/problem/D
题目大意：
有一个n*n网格，保证n是奇数。每个格子内有一个整数。令m=(n+1)/2，可以任意次把一个m*m的矩形中的数乘上-1。求网格中所有数的和的最大值。1<=n<=33
题目解法：
用n*n的矩阵a[i][j]表示一个翻转方案，如果(i,j)被翻转则a[i][j]=1，否则a[i][j]=0。一个方案是合法的当且仅当对于任意1<=i<=n,1<=j<x有a[i][j]^a[i][x]^a[i][j+x]=0且对于任意1<=i<x,1<=j<=n有a[i][j]^a[x][j]^a[i+x][j]=0。2^m枚举a[i][m]，再贪心决定每一列即可。

题目来源：http://codeforces.com/contest/123/problem/E
题目大意：
给一棵n个点的无根树，随机选择起点u和终点v，第i个点被选为起点的概率是xi/sum(xi)，被选为终点的概率是yi/sum(yi)。从起点随机走到终点的代价如下计算：
cost=0
memset(flag,0,sizeof(flag))
function dfs(x)
	flag[x]=true
	if(x==v)return
	random_shuffle(V(x))//V(x)是与x相邻的点集
	for i in V(x)
		if(!flag[i])++cost,dfs(i)
		if(flag[v])return
	++cost
	return
dfs(u)
求最终cost的值的期望。n<=100000
题目解法：
假设以u为根。设x是v的一个祖先。每个x的不包含v的子树有0.5概率在包含v的子树之前被选中。一旦选中错误的子树就必须遍历整个子树，造成2×size的代价。从x向正确子树移动一步的代价是1。因此x和它的错误子树造成代价的期望是子树x的大小减去正确子树的大小。因此总代价的期望是n-size(v)。考虑以v为根，v的每个子树t的贡献是sum(xi in t)/sum(xi)*size(t)。直接统计即可。

题目来源：http://codeforces.com/contest/765/problem/G
题目大意：
有一个长为m的01串s和一个大整数N=Πpi^ai(1<=i<=n)，一个整数k是好的当且仅当对于任意0<i<=m如果s[i]=1那么gcd(k+i,N)=1否则gcd(k+i,N)>1。求[0,N)中好的整数k的个数对1000000007取模。1<=m<=40,1<=n<=500000,1<=pi,ai<=1000000000,pi是质数
题目解法：
假设p1=2。如果k=0(mod 2)，那么s=0?0?0?0?...('?'表示可能是0或1)。如果k=1(mod 2)，那么s=?0?0?0?0...。确定k%pi会使得s中一些位置被确定为0,确定k模所有pi的余数之后就确定了s。如果pi>=m，选定k%pi只会最多确定s中的一个位。因此对大于m的pi可以用未确定是0的位置个数为状态O(nm)DP。但是小于m的状态暴力状压记忆化DP还是不能过。对于pi>m/2再优化一下，如果选择确定s中间的一些位置就只会影响一个位置。然后乱搞一下可能就过了。

题目来源：http://codeforces.com/contest/765/problem/F
题目大意：
给出长为n的数组a，m次询问，每次询问区间[l,r]，求满足l<=i<j<=r的最小的|a[i]-a[j]|。不强制在线。2<=n<=100000,1<=m<=300000,1<=l<r<=n
题目解法：
O(msqrt(n)log(n))莫队应该会TLE。考虑从1到n枚举询问的右端点r。设x=a[r]，对左边大于等于x和小于x的位置分开考虑。以a[l]>=a[r]为例。先找到l最大的一个y=a[l]>=a[r]且l<r的位置，那么对于1<=i<=l,r<=j<=n，ans(i,j)<=y-x。再找到下一个a[l']>=a[r]且a[l']<a[l]且l'<l，那么对于1<=i<=l',r<=j<=n，ans(i,j)<=y'-x。注意到由于l'<l且y'<y，所以ans(i,j)<=y-y'。因此如果y'-x>=y-y'即2(y'-x)>=y-x，那么y'-x对答案是没有影响的。因此每次用线段树找出最大的l'，使a[l']-a[r]<(a[l]-a[r])×0.5，并更新左边的答案，只会有log(ai)个有效的l。a[l]<a[r]的情况同理。时间复杂度O(nlognlogmax(ai)+mlogn)。
