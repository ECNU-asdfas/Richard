题目来源：Facebook Hacker Cup 2016 Final Round Maximinimax Flow
题目大意：
有一个环套树，每个边有权，支持两个操作
1.修改一个边权
2.输入k，你可以给k条边权值临时+1（可以重复），求全局最小割的最大值。
题目解法：
考虑树上的情况，答案就是最小边权，树的形态是没用的，二分答案+权值线段树统计花费即可。
考虑环的情况，答案就是最小值+次小值
考虑环套树，同样二分答案，用树上的方法计算出所有不在环上的边的答案。
对于环，要求的是最小值+次小值>=mid。
我们先把最小值变成次小值-1，如果这个过程中已经达到要求，就跳出。
否则，在之后的所有时刻，最小值和次小值的差不超过1。
对于mid的奇偶性分类讨论：
如果mid是偶数，最小值必然要等于次小值。
二分最小值+权值线段树统计即可。
如果mid是奇数，那么最后的情况肯定是一个最小值和一堆次小值。
类似mid是偶数的时候做，处理一些细节问题即可。
复杂度O(q*log^2(int))

题目来源：Facebook Hacker Cup 2016 Final Round Rainbow String
题目大意：
有一个串，每个位置有一个颜色：生命色，根据相关法律法规色和续命色。
一个子串是合法的，当且仅当这个子串存在至少一个生命色且不存在续命色。
要求回答一堆询问，询问长度为l的子串中字典序第k小的串是哪个。
题目解法：
考虑所有起点，可行的终点都是一个区间，这个区间可以线性预处理出来。
对于所有询问的l排序，用一个set维护所有的合法的起点，set中的顺序是SA的rank值
回答询问时直接在set中找到第k小值就是答案。
复杂度O(q*log(n))

题目来源：Facebook Hacker Cup 2017 Qualification Round Fighting the Zombie
题目大意：有一个若干面的骰子扔若干次，问点数之和至少为x的概率。
题目解法：跑个背包。

题目来源：Facebook Hacker Cup 2017 Round 1 Beach Umbrellas
题目大意：有长度为m的数轴，和n个圆半径已知，你要把所有圆放到数轴上，圆心要在整点，任意两个圆不能相交，求方案数。
题目解法：
首先，如果限制是所有圆不能超过数轴的范围是很好做的，直接全排列。
所以枚举最左边的圆和最右边的圆，然后可以轻易的算方案。
考虑到最左边的圆和最右边的圆的半径之和相同时方案数相同，可以先计算每个和的方案数来降低复杂度。
复杂度O(maxr^2+maxr*n)
可以使用fft以及前缀积优化，复杂度O(maxr*log(maxr)+n)

题目来源：Facebook Hacker Cup 2017 Round 2 Subtle Sabotage
题目大意：
有一个m*n（m列n行）的矩阵是一幅画，画上已经画好了楼房（就是n个有顺序的高度给你的楼）。
你现在要画一个矩形的云，不能和楼房有交，在所有云的下面的且不是楼房的格子画上雨。
你现在要把所有不同的画都画一遍。
问有多少个格子是房子，多少个格子是云，多少个格子是雨，多少个格子是空白。
题目解法：
从小到大排序所有的楼房高度，一起计算云的下边界在两个相邻高度之间的答案。
云能放的位置是若干个区间，每个区间分别考虑计算即可。
到下一个相邻高度区间时，相当于若干个区间合并。
使用大量的前缀和来计算......
细节嘿嘿嘿。
复杂度O(n*log(n))

题目来源：Facebook Hacker Cup 2017 Round 3 Steadfast Snakes
题目大意：
数轴上x=1~n有n个塔，任意两个塔i,j(i!=j)的花费定义为h[i]+h[j]+abs(i-j)。
你可以使k个塔高度减少1（可以重复），每个塔的高度不能被减到0。
最小化最大花费
题目解法：
我们先把所有的h[i]--，约束变成每个塔的高度不能被减到小于0。
定义h-(i)=h[i]-i,h+(i)=h[i]+i。
定义maxh-集合为所有的h-()最大的i的集合，同理定义maxh+集合为所有的h+()最大的i的集合。
可以发现，最大花费一定是在maxh-集合中选择任何一个元素作为左端点，在maxh+集合中选择一个元素作为右端点。
当然，如果一个塔太高了以至于maxh-集合和maxh+集合都只有它一个元素，那么特判。
考虑如何解决问题，问题变成，用一个等腰直角三角形覆盖这些塔的一部分，要求腰在数轴上且要覆盖数轴上的n个点。
这是一个经典问题，枚举中心点，二分高度使用数据结构辅助即可。
复杂度复杂度O(n*log^2(n))
