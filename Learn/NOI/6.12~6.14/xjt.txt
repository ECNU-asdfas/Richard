题目来源：
算法马拉松23（飞越愚人节）E
题目大意：中文题意又短又简单
题目解法：莫队，把绝对值拆开用数据结构维护四个值计算贡献。用线段树会卡常。应该可以通过复杂的讨论直接分块去掉log

题目来源：
算法马拉松23（飞越愚人节）F
题目大意：中文题意又短又简单
题目解法：∑i=1N∑j=1Nsgcd(i,j)K=∑d=2N(dminp(d))K∑i=1⌊nd⌋∑j=1⌊nd⌋ϵ(gcd(i,j))=∑d=2N(dminp(d))K(2∑i=1⌊nd⌋φ(i)−1)
如果能对所有不同的 ⌊ni⌋ 快速计算出 φ(n)和(dminp(d))K的前缀和.问题就很好计算了. 
考虑计算φ(n)的前缀和.
令 S(N)=∑Ni=1φ(i) 
 N∑i=1NiN(N+1)2S(N)====∑d|Nφ(d)∑d=1Nφ(i)⌊Ni⌋∑i=1NS(⌊Ni⌋)N(N+1)2−∑d=2NS(⌊Ni⌋) 
如果我们预处理出N23内的答案,那么就可以在O(N23)内计算出S(n). 
 考虑计算(dminp(d))K的前缀和. 
 将minp(d)按照N−−√分类,注意到如果minp(d)>N−−√,那么有minp(d)=d,它对答案的贡献系数就是1,所以只要数这个范围内的质数就好了. 
 而>N−−√的质数就是和所有≤N−−√的质数都互质的数.如果minp(d)≤N−−√,我们可以考虑用dp解决.用F(i,j)表示在[1,j]中与前i个质数都互质的数字的K次方和.用H(i,j)表示在[1,j]中与前i个质数都互质的数字的个数.用G(i,j)表示所有x∈[1,j],minp(x)≤pi,(xminp(x))K的和.那么我们有:F(i,j)G(i,j)H(i,j)===F(i−1,j)−pKiF(i−1,⌊jpi⌋)G(i−1,j)+F(i−1,⌊jpi⌋)H(i−1,j)−H(i−1,⌊jpi⌋) 
答案就是 G(V,N)+H(V,N),V表示不大于N−−√的最大质数的标号 
如果直接递推的话,复杂度太高了,注意到j只要取在所有不同的 ⌊ni⌋ 的地方就好了,那么第二维只有 O(N−−√) 种取值,复杂度就降为了 O(NlogN) .再次注意到如果 j<pi+1 ,那么有F(i,j)=H(i,j)=1,所以当 pi≤j<p2i 时,我们有 F(i,j)=F(i−1,j)−pki,G(i,j)=G(i−1,j)−1,H(i,j)=H(i−1,j)+1 ,因此我们只要转移 j≥p2i 的j就好了,然后记录每个j最后被更新的位置就可以推算出它的函数值了.
复杂度 O(N34logN) 

题目来源：
算法马拉松24（飞越愚人节）E
题目大意：中文题意又短又简单
题目解法：维护深度奇偶颜色黑白的点数量，修改到根的链询问到根的链的信息，用链剖维护。


题目来源：
算法马拉松24（飞越愚人节）F
题目大意：二位平面上n个点，每个点可以走到一个矩形内的任意点。每个点有权，问第k小路径。
题目解法：记录当前路径最后2个点，扩展可能使路径曾长一步或把最后1个换为能走到的较劣点（记录当前可以查询的区间，每次被当前最小值切成两块）。用堆维护路径，堆中元素是O（k）的。用树套树维护二维区间最小值。

题目来源：
算法马拉松25 F
题目大意：有一个长度为 n(1<=n<=400) 的 01 串 s，花费c[l,r]反转[l,r]的状态，最小化将s变为t的花费。
题目解法：用floyd求最短路。初始串和目标串异或一下,问题变为将目标串变为全0串
将每个i（1～n+1）满足f[i]!=f[i-1]取出，区间反转转化为同时反转2个点。一组答案为关键点的完美匹配，用带花树跑一般图最小权匹配。


题目来源：
算法马拉松25 E
题目大意：
统计区间[a,b]中最大约数小于p的数p,a,b（p<=10^6,a<=10^9,b-a<=10^8）
题目解法：先把2至p所有质数预处理出来。记第k个质数为p_k。令f(x,y,b)表示[x,y]中所有质因子不大于p_b的数个数。
分以下几种情况：
若x>y则f(x,y,b) = 0
若b=0且x=1<=y则f(x,y,b)=1
若x=y则暴力分解x看是否满足。（可以部分预处理）
若y<=p_b则f(x,y,b)=y-x+1
否则f(x,y,b)=f(x,y,b-1)+f(x/p_b,y/p_b,b) （上取整）
最后一种情况的意思是，当前[x,y]中质因子不包含p_b的数。后一个是至少包含一个p_b的数，可以把p_b除下去以后递归求解。
用map记忆化会T
