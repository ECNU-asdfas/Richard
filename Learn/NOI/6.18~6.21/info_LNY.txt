题目来源：POI2014 Salad Bar
题目大意：
有一个长为n的01序列，区间[l,r]是好的当且仅当[l,r]从左到右和从右到左数1的个数都总是不小于0的个数。求最长的好的区间的长度。n<=1000000
题目解法：
先处理前缀和，然后从左到右扫，用一个栈存所有还合法的区间的左端点，求出只考虑从左数时以每个点为左端点合法的最右边的右端点。从右往左扫，同样用栈存合法的右端点，对每个左端点二分查找左右都合法的右端点。

题目来源：POI2014 Hotels
题目大意：
有一棵n个节点的树，求dis(u,v)=dis(v,w)=dis(w,u)且u,v,w互不相同的三元组(u,v,w)数量。n<=5000
题目解法：
设x是以w为根时LCA(u,v)，则dis(x,u)=dis(x,v)=dis(x,w),枚举x作为根，计算取相同深度的点的方案数。

题目来源：POI2014 Bricks
题目大意：
有k种颜色的砖，第i种颜色有a[i]块，一共n块，要求把n块砖排成一排，最左边一块颜色是p，最右边一块颜色是q，相邻砖块颜色不同，输出任意一种方案，若不存在输出0。n<=1000000
题目解法：
拿出最多的颜色，放在开头结尾之间，如果剩余砖块不够分开这种颜色就无解。讨论一下贪心即可。

题目来源：POI2014 Couriers
题目大意：
有一个长为n的序列p，1<=pi<=n，有m次询问，每次询问区间[l,r]是否存在一个数出现次数大于(l+r)/2。n<=500000
题目解法：
建一棵主席树，每次向size大于一半的儿子走。

题目来源：POI2014 Cards
题目大意：
有一个长为n的卡片序列，第i张卡片两面的数字分别是xi和yi。表演成功当且仅当给每张牌指定一面朝上以后朝上数字的序列单调不下降。有m次操作，每次交换aj和bj两张牌。每次操作后输出是否表演成功。n<=200000,m<=1000000,0<=xi,yi<=10000000
题目解法：
用线段树维护一个区间最左端最右段分别是正面反面时是否合法。交换时直接修改两个位置。

题目来源：POI2014 Supercomputer
题目大意：
有n个任务形成一棵树，第i个任务的父亲是a[i](i>=2,1<=a[i]<i)，任务1是树根，没有父亲。计算能力为a表示每秒可以选出至多a个父亲已经完成的任务，在这一秒同时完成。有q次询问，每次给出ki,询问计算能力为ki时至少需要多少秒完成所有任务。1<=n,q,ki<=1000000
题目解法：
把任务按深度分层。设s[i]为深度大于i的任务数量，maxdep为最大深度。那么对于询问k，ans=max{i+ceil(s[i]/k)}。
证明：
第i次取的时候，如果第i层的任务数量不超过k，那么取完第i层，并任意尽量多取前i层的未完成的任务，否则在第i层贪心取子树深度最大的k个任务。这样做是最优的。
第一次取到深度等于i的节点一定是第i次操作。假设这次操作取完了前i层，并且以后除了最后一次以外每次操作都能取至少k个，那么答案就是i+ceil(s[i]/k)，相当于大于i层的部分不受到父亲关系限制的答案。把这样的一次操作称为关键操作，第1次操作一定是关键的。只有关键操作和最后一次操作会取少于k个。
假设这次操作取完了前i层，并且之后存在不是最后一次的第j>i次操作没有取满k个，那么第j次取完了前j层，也就是说j是一个关键操作，答案是j+ceil(s[j]/k)>=i+ceil(s[i]/k)。
假设这次操作没有取完前i层，那么i之前的最后一次关键操作j和i之间的操作都取了k个，i+ceil(s[i]/k)<=j+ceil(s[j]/k)。
所以综上，ans=max{i+ceil(s[i]/k)}。
变形一下，ans=ceil(max{i+s[i]/k})=ceil(max{ik+s[i]}/k)。斜率优化即可。

题目来源：POI2014 Little Bird
题目大意：
有n棵树排成一排，第i棵树高度为hi。q只鸟要从第1棵树飞到第n棵树。第i只鸟的飞行能力是ki，每次可以从第j棵树飞到第j+1,j+2,...j+ki棵树。如果一次飞行从i到j且hi<=h[j]那么会有1点劳累值，否则这次飞行不增加劳累值。求每只鸟的最小劳累值。2<=n<=1000000,1<=h[i]<=1000000000,1<=q<=25,1<=ki<=n-1
题目解法：
对每个询问分别处理。f[i]=min(min{f[j]+1}(hj<=h[i]),min{f[j]}(h[j]>h[i]))。但是用树状数组不太方便。注意到如果f[k]<f[j]，那么即使h[k]>h[j]也有f[k]+1<=f[j]。使用单调队列，把位置j加进队尾时把队尾所有f[k]比f[j]大的k删掉，把f[k]=f[j]且h[k]>h[j]的k删掉，把超过飞行距离的队首也删掉，转移时取队首。时间复杂度O(qn)。

题目来源：POI2014 Rally
题目大意：
有n个点m条边的有向无环图，删掉一个点使得剩下图的最长路最短。2<=n<=500000,1<=m<=1000000
题目解法：
先求出每个点v作为结尾的最长路长度f1(v)和作为开头的最长路长度f2(v)。设一条边(u,v)的权值w((u,v))=f1(u)+f2(v)，也就是经过(u,v)的最长路长度。对于任意有向无环图的一个割集，割集中的边的权值的最大值就是这个图的最长路。新建源点S连向所有点或所有入度为0的点，按照拓扑序把点从T集合移到S集合。这样可以保证S集合中所有点的拓扑序小于T集合中任意点的拓扑序。用大根堆维护割集。每次取出T集合拓扑序最小的点，将连向它的边从割集中删去，用堆顶更新答案，再把它连向的边加入割集。

题目来源：POI2014 FarmCraft
题目大意：
有一棵n个点的树，每个节点有一台电脑。管理员从1号点开始经过每条边恰好2次，经过所有点并回到1号点，第一次到达i>1号点时i点的电脑会开始自动安装游戏，管理员停留时间不计。管理员最后一次回到1点时1点的电脑才会开始安装游戏。第i个点的电脑安装游戏需要1秒，经过每条边需要1秒。求最优情况下全部完成安装的最早时间。2<=n<=500000
题目解法：
树形DP求出每个子树从进入树根到最早完成安装的时间，在每个节点按照子树耗时从大到小遍历。

题目来源：POI2014 Around the world
题目大意：
有一个n个点的环，i号点与下一个点之间的距离是li。有s个询问，每次给出d，表示可以从一个点飞到环上距离不超过d的点，问从任意点开始飞回原点的最小飞行次数。2<=n<=1000000,1<=s<=100,1<=d<=sum(li)<=1000000000
题目解法：
对每个询问分别处理。预处理点i能一次飞到的最远点next[i]。按顺序枚举出发点，记忆化暴力是O(n)的。

题目来源：POI2014 Ant Colony
题目大意：
有一棵n个点的树，每个叶子节点有g群蚂蚁。每群蚂蚁会依次进入树中，以所在的叶子节点为根开始BFS。当一群数量为m的蚂蚁进入一个有d个儿子d+1条边的节点时会分成d群，每群[m/d]只，分别进入每个儿子。如果m不被d整除，会有m-[m/d]*d只蚂蚁消失。如果m<d或d=0蚂蚁会全部消失。有一条边上有一只食蚁兽。它会吃掉一群经过这条边的蚂蚁当且仅当这群蚂蚁恰好有k只。当树中不再有蚂蚁时下一群蚂蚁才会进入这棵树。每个叶子的第i群蚂蚁有mi只。问食蚁兽吃了多少只蚂蚁。2<=n<=1000000,2<=g<=1000000,1<=k,mi<=1000000000
题目解法：
从食蚁兽所在的边开始bfs，求出每个节点i进入x只蚂蚁时会被食蚁兽吃掉的x的范围[li,ri]。当li大于所有mi时可以不再增大防止炸longlong。对mi排序之后在每个叶子节点二分查找。

题目来源：POI2014 Tourism
题目大意：
有一个n个点m条边的无向图，保证最长简单路径经过点数小于等于10。给第i个点染色的代价是ci。求最小染色总代价使每个未被染色的点都与至少一个染色点直接有边相连。n<=20000,m<=25000,0<=ci<=10000
题目解法：
任意dfs树的深度小于等于10。每个点连的非树边都连向它的祖先。DFS过程中记下每个祖先的状态是已染色/未染色已合法/未染色不合法，DP即可。复杂度O(3^10*n)。

题目来源：POI2014 Solar lamps
题目大意：
平面上有n盏太阳能电灯。有两个向量(x1,y1),(x2,y2)，在(X,Y)位置的灯i照到的范围是∠(x1+Xi,y1+Yi)(Xi,Yi)(x2+Xi,y2+Yi)。一开始所有灯都关着。管理员会在第i秒来到第i
盏灯，如果第i盏灯还没有亮就将它打开。由于是太阳能电灯，第i盏灯在被ki盏灯照到的时候就会被打开。求每一盏灯在第几秒被打开。n<=200000,-1000000000<=Xi,Yi,x1,x2,y1,y2<=1000000000,1<=ki<=n
题目解法：
以(x1,y1)和(x2,y2)为基重新计算坐标。设一盏灯i被打开的时间是a[i]，a[i]<i当且仅当i的左下角的灯的a的第ki大小于i。按照第一关键字横坐标第二关键字纵坐标排序，维护a的权值线段树套纵坐标的平衡树，在权值线段树上二分答案，在平衡树上修改即可。两个向量重合时要特判。

题目来源：POI2014 Solar Panels
题目大意：
n次询问，每次给出l1,r1,l2,r2，求max{gcd(i,j)}(l1<=i<=r1,l2<=j<=r2)。1<=n<=1000,1<=l1<=r1<=1000000000,1<=l2<=r2<=1000000000
题目解法：
枚举答案，ans的倍数可能是答案要求[l1,r1]和[l2,r2]中都有ans的倍数，所以[(l1-1)/ans]<[r1/ans]且[(l2-1)/ans]<[r2/ans]。因为[x/y]只有O(sqrt(x))种取值，将[()/ans]的值相同的O(sqrt(x))个区间拿出来，4种取值都相同的块还是只有O(sqrt(1000000000))种。对每一个合法块取最大值更新答案。
