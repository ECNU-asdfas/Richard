题目来源：Facebook Hacker Cup 2016 Qualification Round Text Editor
题目大意：有n个单词，你可以选择k个任意排列，两个相邻的串的贡献是他们的最长公共前缀，求最大贡献。
题目解法：
把n个单词排序（用后缀数组加速），然后dp即可。
复杂度O(n*k)

题目来源：Facebook Hacker Cup 2016 Round 1 Boomerang Tournament
题目大意：16个人打淘汰赛（16->8->4->2->1），给出胜负表，问每个人的最高/低排名。
题目解法：
首先，最低排名是很好做的，如果一个人会失败，他就在第一轮gg否则rk1。
C(16,8)枚举一个8个人的集合作为第一轮晋级的人，用匹配判断是否可行。
然后只有8个人了，想怎么做怎么做。
复杂度O(C(n,n/2)*n^2))

题目来源：Facebook Hacker Cup 2016 Round 2 Costly Labels
题目大意：
给一个n个点的树染色，第i个点染颜色j有c[i][j]的花费。
定义一个点是坏的当且仅当它的邻居中至少有2个颜色一样。
总花费=染色花费+p*坏的点数。
求最小总花费。
题目解法：
随便找个点提根。考虑深度为奇数的点和深度为偶数的点互不影响，分开计算。
设f[s][c]为以s为根的子树，根的颜色是c的花费。
对于s的每个儿子，有两种情况：
这个儿子是坏的，直接把孙子们的最小的f值相加即可。
这个儿子是好的，相当于要把孙子们和颜色作一个最大权完美匹配。
复杂度O(n*k^2.5)

题目来源：Facebook Hacker Cup 2016 Round 3 Transportation
题目大意：有一个l个点的环，边有权值，其中n个点是公交车站，现在随机拆掉k个，你在一个随机的位置，求你离最近的车站的距离的期望。
题目解法：
先考虑一个O(n^2)的做法：
枚举两个车站i和j，令d为i和j之间的点数,D为i和j的距离。
把i到j之间所有的点干死，概率是C(n-d-2,k-d)/C(n,k)。
如果你在i~j之间，那么你的期望距离就是D/4，这样的概率是D/l。
所以一对(i,j)的贡献就是C(n-d-2,k-d)/C(n,k)*D^2/4l。
考虑优化，用fft计算s[d]=sigma(d(i,j)=d)(D^2)
可以直接作出答案。
复杂度O(n*log(n))


题目来源：Facebook Hacker Cup 2017 Final Round Fox Holes
题目大意：有一个0~2n+1的数轴，1~2n的每个点有个颜色，每个颜色出现2次，你要从0走到2n+1，每次跳1格或2格，不能踩到相同颜色的格子，问方案数量。
支持交换序列的任意两个位置的颜色，不断询问答案。
题目解法：
首先，你每个颜色肯定经过1次。
所以你只跳的步数只能有1次是1步。
令跳1步的位置为x
一个l,r((r-l)%2=0)要求x inside [l,r-1]
一个l,r((r-l)%2=1)要求x outside [l,r-1]
线段树维护。
复杂度O(n*log(n))

题目来源：Facebook Hacker Cup 2016 Round 2
题目大意：数轴上有一堆杆子，太阳高度角在[A,B]之间随机，求地上的阴影长度和的期望。
题目解法：
[A,B]和[0,R]是等价的，做[0,R]。
考虑每个杆子，定义一个杆子的父亲是最早覆盖这个杆子的杆子，这个可以扫一扫搞个凸壳求出来。
计算每个杆子的贡献时只需要考虑它的孩子即可。
复杂度O(n*log(n))
