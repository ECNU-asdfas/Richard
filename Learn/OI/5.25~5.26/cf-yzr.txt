1.338D. GCD Table
给一个序列a1..ak，问是否在n*m的GCD表中出现一个横行为ai .n,m<=1e12,k<=1e4
题解：首先行为lcm(ai)时最优，然后设第一列的位置x，可以得到a1|x, a2|x+1, a3|x+2 ...
此外还有一些限制是gcd(lcm/a1,x/a1)=1。考虑解上述同余方程，x=x0+lcm*k，发现gcd(这些x,lcm)不变。因此扩展CRT即可。别忘了判出现位置在(n,m)内；别忘了最后检验一遍（来保证gcd恰好=输入的）；别忘了写慢速乘

2.338E Optimize!
input ai/bj/h，长度为n/m，问a中有多少个len=m的区间和b形成完美匹配。ai,bj间有边当且仅当ai+bj>=h。
题解：很显然对b排序后贪心地匹配即可，问题变成“有多少len=m的区间最大数>=b1，次大数>=b2……”。考虑hall定理，选出k个b中的数显然会选最大的k个，要求a中>=bk的有>=k个。可以考虑扫一遍a序列，同时维护vi表示>=bi的有几个数-i，这样合法条件为min{vi}>=0。线段树维护，需要后缀加/查询全局min。O(nlogn)

3.319D Have You Ever Heard About the Word
输入串S，每次找到最短的AA子串（且最左），删掉一个A。求最终串。n<=5e4
题解：首先结论为删去串的长度不降。然后由于是线性扫过去常数很小，就可以枚举长度后暴力匹配O(n^2)过了。靠谱的做法是每L位设一个关键点，求向前/向后的lcp即可，利用hash+二分，如果枚举到了一个删除串就重构hash。O(n^1.5+nlog^2n)

4.319E Ping-Pong
(1)ins [x,y]，保证长度递增
(2)询问区间x 能否移到区间y，(a,b) --> (c,d) 当且仅当c<a<d || c<b<d
q<=1e5
题解：考虑把相交的线段缩起来，维护出这一坨线段的左端点&右端点。发现由于保证长度递增，插入的区间[l,r]如果和缩起来的新区间有交（可以被包含，但不能包含）则可以并起来（画图易知在那一坨区间中必定能找到一条和[l,r]相交）。而缩完后的那些区间性质如下：两两不相交，小区间能走到大区间，而大区间不能走到小区间。特判两个区间相等的情况，只可能是1整个区间 & 若干个小区间，此时情况为小区间能走到一整个区间。
考虑如何维护，显然缩点可以dsu，可对于[l,r]，怎么找出和他相有交的线段呢？可以使用树套树暴力维护，合并时只要把一个矩形内的点找出来并起来即可。O(nlog^2n)
但这题由于保证长度递增，只需找到跨越该区间端点的区间即可（不可能包含当前区间）！因此可以使用线段树维护，每个节点是一个vector。O(nlogn)。为方便写代码，可以并查集的root为块内最大数，每次并完ins [l+1,r-1]。






Comment：做这种题时得多想想“保证长度递增”有哪些用处，可能会让不可做变成可做，也可能会优化复杂度、简化代码。



