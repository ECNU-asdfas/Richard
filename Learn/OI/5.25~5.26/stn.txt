51nod算法马拉松32A
题意：对一个数n，它的特殊表示法为a[1]*F[1]+a[2]*F[2]+...a[n]*F[n]。其中a[1..n]为一个取值0/1的数列。（不包括F[0]）同时，规定a数列不存在两个相邻的1，并且a[n]=1。现在给两个数A和B的特殊表示法，需要你求出A+B的特殊表示法。n,m<=1e6
题解：将两个对应位置相加，然后暴力进位，暴力处理>=2的位置即可。

51nod算法马拉松32B
题意：一个n个点的有标号树，叶子数目不变，求有多少种不同的形态。n,m<=1e6
题解：注意到当一个节点为叶子当且仅当他不出现在prufer编码中，则结果为C(n,m)*f(n-m)，f(i)表示有多少长度为n-2的序列满足这里面恰好出现了i种元素，容斥一下。

51nod算法马拉松32C
题意：每次给一个区间的set中加入一个数，询问一个区间中的严格第k小。数字<=10000 n,q<=65536 3.5s
题解：线段树加bitset卡卡常

51nod算法马拉松32D
题意：n个字符串，每次询问给出x,y问有多少本质不同的回文串同时出现在ax,ay两个串中。n<=100000 ∑ai<=100000 q<=100000。
题解：考虑每个串本质不同的回文子串个数最多为len个，求两个串的答案是O(min(len[x],len[y]))的，考虑len大于根号的只有根号个，求出两两之间的答案，小于根号的询问时暴力。实际做的时候只要记忆化一下就好了。

51nod算法马拉松32E
题意：对Πai!(i=1..n)化简为t*Π(ci!)^ei(i=1..k) 其中c1>c2>...ck>1 且需要得到按照序列c1,e1,c2,e2,...,ck,ek进行字典序排序后的最大的答案。n<=1e5 ai<=1e5
题解：把Πai!质因数分解。考虑c1最大只能是比1e5大的最小的那个质数-1。从那个数开始枚举尝试分解，能得倒的话相当于可以有prime个数/需要的个数的最小值那么多个。然后对这个建一个堆维护最小值，把他分解掉相当于整个堆-一个值。然后当分解下一个数的时候，考虑n!比n-1!多了一个n，把n的质因数对应的值拿出来，重新计算prime个数/需要的个数，然后放回堆里即可。

51nod算法马拉松32F
题意：给定n和m，求Π{X∈S}lcm(X1,X2,...,Xn)^gcd(X1,X2,...,Xn)mod 1e9+7。其中X是一个序列，S是所有满足长度为n，且∀{1<=i<=n}Xi∈[1,m]的序列的集合。显然，有m^n种序列。
题解：https://img-blog.csdn.net/20180102164340784 https://img-blog.csdn.net/20180102164331488
