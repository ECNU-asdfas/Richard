51nod 算法马拉松33

A:
题意:将1~n(5e8)按顺序入栈,记一个入栈方案的价值为对于每次入栈时栈中元素的权值和,对于每种入栈方案的价值和.
题解:
	f[i]表示1~i的入栈的种类数
	g[i]表示1~i入栈的对于每种情况栈内元素个数的和求sigma
	h[i]表示1~i入栈的对于每种情况栈内元素值的和求sigma 
	考虑两两之间的转移:
	f[0]=1
	f[i]=sigma(f[j-1]*f[i-j])
	g[i]=sigma(f[j-1]*g[i-j]+(g[j-1]+j*f[j-1])*f[i-j])
	h[i]=sigma(f[j-1]*(h[i-j]+g[i-j]*j)+(h[j-1]+f[j-1]*j+g[j-1])*f[i-j])
	然后就h[n]即为所求的解
	最后h[n]=n*4^(n-1)/2+binomal(2n-1,n-1))/2*n,预处理阶乘即可.
B:
题意:求n(1000)个点的左偏树的个数
题解:因为n个点的左偏树最多dis为logn,所以状态为f[n][m]表示n个点且dis为m的左偏树的个数,暴力n^2logn^2可过,可以用前缀和优化一个logn


C:
题意:有n(1e5)个数,n为偶数,分成n/2对点对,每个点对的权值为两个权值的乘积.
	m次操作,每次修改一个数,或求求最大字典序的第k个位置
题解:考虑如果只有整数只要维护n个数的排序数列,然后求第k大即可,那么加上负数,只需要分别维护即可:
	对于询问,那么二分最后的ans是正数序列或负数序列的第k大,然后在权值线段树或平衡树上判断一下即可.

D:
题意:考虑从(0,0)到(Tx,Ty)(1e6)总共走R步,然后一步最多(横坐标走Mx)(纵坐标走My),然后还有一些(50)限制(ki,ki)表示不能横纵坐标不能同时为ki.
	然后对于每个限制都一定是G(10000~50000)的倍数,最后求最后走到终点的方案数
题解:
	首先横纵坐标独立
	然后先不考虑限制,那么对于横坐标,那么相当于分成R个小于Mx的且和为Tx的方案数,
		那么在考虑有x的超出Mx的方案数,然后容斥一下即可求出没有超出的方案数,
	对于纵坐标同理.
	于是在加上限制,那么就求出用i个限制组成的j的方案数
	用fi表示至少用i个限制的方案数,gi表示刚好用i个限制的方案数
	那么容斥一下即可

E:

F:
题意: