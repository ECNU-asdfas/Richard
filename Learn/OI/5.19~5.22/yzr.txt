A:input a,b,c,k，进行k次操作“a'=b+c; b'=a+c, c'=a+b”，问最终的a-b。 0<=a,b,c,k<=1e18。
题解：显然每次操作a-b取反

B:input Pi（排列），每次操作可以选一个数扔到首部或尾部，问最少几次操作得到升序。很显然保证有解。n<=2e5
题解：注意到扔到首部的是一个值域上的前缀，扔到尾部的是一个值域上的后缀，中间不动的是值域连续且位置递增的数。最大化中间点个数扫一遍即可。

C:input Ai,有一个Xi=0的序列，每次操作指定一个1<=i<n,X[i+1]=X[i]+1.问最少几次操作使得A=X或指出无解.n<=2e5,Ai<=1e9
题解：首先Ai可以划分成若干个公差=1的等差数列（均>0），考虑如果可以做到显然会从后往前地构造，对于每个等差数列从它向前延伸到值为1的地方开始向后一直扩展，这样的步数是sigma{等差数列最高点}，已经最优了。问题在于如何判不合法，手画一些样例可以得到：(1)Ai>=i (2)Ai-1<Ai-1

D:input Tree，定义一棵树的美丽度是最少的染色数使得以同种颜色的点为根的有根树同构。可以往树中加任意多个点（接在某个已有点上）得到新树T，求（1）T的最小美丽度 （2）达到最小美丽度时的最小叶子数。 n<=100
题解：很显然第1问的答案=(D+1)/2，因为可以加任意多个结点。考虑什么时候可以取到这个最小值，手画大量样例（划掉）可得只有2种情况（1）把一个点提根，使得所有深度相同点同构 （2）选一条边，得到2棵子树，要求这2棵子树同构且每个子树中深度相同点同构。现在我们只需解决“给出若干个子树，要求它们同构且深度相同点同构”的问题，ans=maxdeg（这些子树的根）* 递归下一层的答案。 至于为什么是对的话我其实只知道看起来很有道理233333

E:input n,m,k,求(A0,A1,...,An)的对数%m，满足|Ai|=i，Ai-1是Ai的子序列，Ai的字典序>Ai-1，Ai的每个数为[1,k]。n,k<=300,2<=m<=1e9
题解：首先很显然如果已知Ai-1求Ai的方案数，由于要使字典序变大要么在某个位置放入更大的数要么随便扔一个数在末尾，这样做不会算重因为如果有若干个相邻Ai是一样的，并且我们要在那个位置加入同样大小的数，只会在相同那一坨数后面那个位置被统计一次。故ans=sigma{k-aj}+k。也就是说我们只关心某个数列每个数值出现次数而不用管顺序。
假设当前有一个数列，记cnti为i出现的次数，si=sigma{cntj, j<i}+1，考虑在当前数列的基础上每次操作新生成的数构成一个操作序列，一个操作序列对应的方案数=PI(每个数的si + 序列中这个位置前面比它小的数的个数)，操作序列中相同数的顺序不同只算1遍。这很显然可以dp。考虑从小到大往操作序列中插数，每个数的系数（乘到答案里的数）是关于插入位置的一次函数。
f[i][j]表示目前插了<=i的数，已经插了j个，转移到f[i+1][k]的系数为S(si+1,j,k-j)。其中S(i,j,k)表示当前要插的数初始权值是i（即s[x]），原有j个数，插k个数的答案。然而似乎要O(n^4)？冷静观察一下发现原数列是空的，因此si=1，所以s[i][j]表示长为i的序列里插了j个数，那些空位的系数为1..i+1，这样总复杂度就是O(n^3)的了，写起来也很方便。转移如下：
s[i][j]=simga{s[i-1][j-p]*(i+1)^p,p>=0}, f[i][j]=sigma{f[i-1][k]*s[k][j-k],k<=j}

F:input n,k,集合S, S是所有长度<=n的01串集合的子集，要求最长的01串使得它是至少k个S中的串的子序列。若有多个合法串输出字典序最小的。 n<=20, k<=|S|因此一定有解（答案可以是空串）。
题解：考虑如何表示一个01串S的所有本质不同的子序列。初步的想法是利用DAG上的传递闭包来不重复地表示出每个子序列。比如[11011]-->[] | 1[1011] | 0[11]，即枚举子序列的第一个字符（或为空），显然贪心地匹配S的第一个可以匹配的位置。这样状态可以这样表示（S,len），S为串的标号，len为末尾还没有匹配的长度。直接在DAG上dp就可以算出每个len<=n的01串作为子序列在S中的串出现总次数，就做完了。实现的话topsort的时候注意判断一个状态是否合法。





